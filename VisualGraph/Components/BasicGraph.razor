@inject IGraphService GraphService
@if (GraphModel != null && SvgDisplay != null)
{
    var activenode = GraphModel.ActiveNode;
    <svg id="@(GraphModel.Name)" class="vssvg img-fluid" viewBox="@(SvgDisplay.ViewBox)" style="@SvgDisplay.RatioLimit"
         @onclick="@OnSvgClick"
         @onmousemove="@OnSvgMouseMove"
         @onmouseup="@OnSvgMouseUp"
         @onmousedown="@OnSvgMouseDown"
         @onmousewheel="@OnSvgMouseWheel"
         @onkeydown="@OnSvgKeyDown"
         @ontouchmove="@OnSvgTouchMove">
        <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                    markerWidth="6" markerHeight="6"
                    orient="auto-start-reverse">
                <path d="M 0 0 L 9 5 L 0 10 z"
                      stroke="@GraphStyleParameters.EdgeStrokeColor"
                      stroke-width="@GraphStyleParameters.EdgeWidthText" />
            </marker>
            <marker id="axisarrow" viewBox="0 0 10 10" refX="5" refY="5"
                    markerWidth="10" markerHeight="10"
                    orient="auto-start-reverse">
                <path d="M 0 0 L 9 5 L 0 10"
                      stroke="grey"
                      stroke-width="0.4"
                      fill="none" />
            </marker>
        </defs>
        @CoordinateAxis.GenerateForGraphRange(GraphModel.ConvexHull[0].X, GraphModel.ConvexHull[0].Y, GraphModel.ConvexHull[1].X, GraphModel.ConvexHull[1].Y);
        @if (activenode != null)
        {
            <line x1="@activenode.PosXText" y1="@activenode.PosYText" x2="0" y2="@activenode.PosYText" style="@($"stroke:rgba(0,0,0,0.5); stroke-width:0.1")"></line>
            <line x1="@activenode.PosXText" y1="@activenode.PosYText" x2="@activenode.PosXText" y2="0" style="@($"stroke:rgba(0,0,0,0.5); stroke-width:0.1")"></line>
        }
        @foreach (var edge in GraphModel.Edges)
        {
            if (edge.StartNode != null && edge.EndNode != null)
            {
                <g>
                    @{
                        var reverseEdge = GraphModel.Edges.FirstOrDefault(x => x.StartNode == edge.EndNode && x.EndNode == edge.StartNode);
                        var halfwayx = ((edge.StartNode.Pos.X + edge.EndNode.Pos.X) / 2).ToString(CultureInfo.InvariantCulture);
                        var halfwayy = ((edge.StartNode.Pos.Y + edge.EndNode.Pos.Y) / 2).ToString(CultureInfo.InvariantCulture);
                        if (GraphModel.IsDirectional)
                        {
                            var dir = Vector2.Normalize(edge.EndNode.Pos - edge.StartNode.Pos);
                            var startPos = edge.StartNode.Pos + dir * (float)GraphStyleParameters.NodeRadius;
                            var endPos = edge.EndNode.Pos - dir * ((float)GraphStyleParameters.NodeRadius + (float)GraphStyleParameters.NodeStrokeWidth);
                            if (reverseEdge == null)
                            {

                                <line class="@(((ICSSProperties)edge).ClassesProppertie) edge"
                                      x1="@((startPos.X).ToString(CultureInfo.InvariantCulture))"
                                      y1="@((startPos.Y).ToString(CultureInfo.InvariantCulture))"
                                      x2="@((endPos.X).ToString(CultureInfo.InvariantCulture))"
                                      y2="@((endPos.Y).ToString(CultureInfo.InvariantCulture))"
                                      marker-end="url(#arrow)" />
                                @((MarkupString)$"<text x=\"{@halfwayx}\" y=\"{@halfwayy}\" >{String.Format("{0:0.00}", @edge.Weight)} <tspan class=\"hovertext\">Distanz: {String.Format("{0:0.00}", @edge.AutoWeight)}</tspan></text>")
                            }
                            else
                            {
                                var curvepoint = startPos + dir * ((endPos - startPos).Length() / 2);
                                var rotatedDir = Vector2.Transform(dir, Matrix3x2.CreateRotation(MathF.PI / 2));
                                var lengthofVector = rotatedDir * (curvepoint - startPos).Length();
                                var disiredPoint = lengthofVector * 0.2f + curvepoint;
                                var testpos = lengthofVector * 0.1f + curvepoint;
                                <path class="@(((ICSSProperties)edge).ClassesProppertie) edge"
                                      d="M @startPos.X.ToString(CultureInfo.InvariantCulture) @startPos.Y.ToString(CultureInfo.InvariantCulture) Q @disiredPoint.X.ToString(CultureInfo.InvariantCulture) @disiredPoint.Y.ToString(CultureInfo.InvariantCulture) @endPos.X.ToString(CultureInfo.InvariantCulture) @endPos.Y.ToString(CultureInfo.InvariantCulture)"
                                      marker-end="url(#arrow)" />
                                @((MarkupString)$"<text x=\"{@testpos.X.ToString(CultureInfo.InvariantCulture)}\" y=\"{@testpos.Y.ToString(CultureInfo.InvariantCulture)}\">{String.Format("{0:0.00}", @edge.Weight)} <tspan class=\"hovertext\">Distanz: {String.Format("{0:0.00}", @edge.AutoWeight)}</tspan></text>")
                            }
                        }
                        else
                        {
                            var startPos = edge.StartNode.Pos;
                            var endPos = edge.EndNode.Pos;
                            if (reverseEdge == null)
                            {
                                <line class="@(((ICSSProperties)edge).ClassesProppertie) edge"
                                      x1="@((startPos.X).ToString(CultureInfo.InvariantCulture))"
                                      y1="@((startPos.Y).ToString(CultureInfo.InvariantCulture))"
                                      x2="@((endPos.X).ToString(CultureInfo.InvariantCulture))"
                                      y2="@((endPos.Y).ToString(CultureInfo.InvariantCulture))" />
                                @((MarkupString)$"<text x=\"{@halfwayx}\" y=\"{@halfwayy}\" >{String.Format("{0:0.00}", @edge.Weight)} <tspan class=\"hovertext\">Distanz: {String.Format("{0:0.00}", @edge.AutoWeight)}</tspan></text>")
                            }
                        }
                }
            </g>
        }
    }
        @foreach (var node in GraphModel.Nodes)
        {
            var name = node.Name;
            @((MarkupString)$"<text class=\"nodeText\" x=\"{ (@node.Pos.X + GraphStyleParameters.NodeRadius).ToString(CultureInfo.InvariantCulture)}\" y=\"{(@node.Pos.Y + 2 * GraphStyleParameters.NodeRadius).ToString(CultureInfo.InvariantCulture)}\">{@node.Name}</text>");
            if (node.IsActive)
                @((MarkupString)$"<text class=\"nodeText\" text-anchor=\"middle\" x=\"{ (@node.Pos.X).ToString(CultureInfo.InvariantCulture)}\" y=\"{(@node.Pos.Y + 2 * GraphStyleParameters.NodeRadius + GraphStyleParameters.TextSize * 0.9).ToString(CultureInfo.InvariantCulture)}\"> { String.Format("P( {0,0:0.00} ; {1,0:0.00} )", @node.Pos.X, @node.Pos.Y)}</text>")
                <circle id="@($"node-{ node.Id}")"
                        class="vsnode @node.Activeclass @(((ICSSProperties)node).ClassesProppertie)"
                        cx="@node.PosXText"
                        cy="@(node.PosYText)"
                        r="@GraphStyleParameters.NodeRadiusText"
                        @onclick="(args) => { OnNodeClick(args, node); }" onclick:event.stopPropagation
                        @onmousedown="(args) => { OnNodeMouseDown(args, node); }" onmousedown:event.stopPropagation
                        @onmouseup="(args) => { OnNodeMouseUp(args, node); }" onmouseup:event.stopPropagation
                        @ontouchstart="(args) => { OnTouchStart(args, node); }" ontouchstart:event.stopPropagation
                        @ontouchenter="(args) => { OnTouchEnter(args, node); }" ontouchenter:event.stopPropagation
                        @ontouchend="(args) => { OnTouchEnd(args, node); }" ontouchend:event.stopPropagation>
                </circle>
            }
    </svg>
    <div id="legend">
        <span class="col"><a class="startnode legend-node"></a> Startknoten</span>
        <span class="col"><a class="endnode legend-node"></a> Endknoten</span>
        <span class="col"><a class="active legend-node"></a> Aktiver Knoten</span>
        <span class="col"><a class="legend-edge"></a> Kante</span>
        <span class="col"><a class="pathedge legend-edge"></a> Kante auf der günstigsten Route</span>
    </div>
}



@code {

    public SvgDisplay SvgDisplay;

    private DotNetObjectReference<BasicGraph> dotnetreference;

    [JSInvokable("UpdateDisplay")]
    public Task<bool> UpdateDisplay(SvgPanZoomInformation svgInformation)
    {
        return Task.FromResult(SvgDisplay.UpdateDisplaySettings(svgInformation));
    }

    [Parameter]
    public BasicGraphModel GraphModel { get; set; }

    private string oldGraphName;
    bool hasUpdates = false;

    protected override void OnParametersSet()
    {
        if (oldGraphName != GraphModel.Name)
        {
            SvgDisplay = new SvgDisplay(GraphModel.ConvexHull[0].X - 10, GraphModel.ConvexHull[0].Y - 10, GraphModel.ConvexHull[1].X + 10, GraphModel.ConvexHull[1].Y + 10);
        }
    }
    protected override async Task OnAfterRenderAsync(bool firstrender)
    {
        await base.OnAfterRenderAsync(firstrender);

        if (firstrender)
        {
            dotnetreference = DotNetObjectReference.Create(this);
        }
        if (oldGraphName != GraphModel.Name)
        {
            oldGraphName = GraphModel.Name;
            await GraphService.InitZoomPan(dotnetreference, GraphModel.Name);
            var displayinfo = await GraphService.GetSvgContainerInformation(GraphModel.Name);
            hasUpdates = SvgDisplay.UpdateDisplaySettings(displayinfo);

            StateHasChanged();
            return;
        }

    }

    public void ChangedState()
    {
        StateHasChanged();
    }

    public async Task ChangedModel()
    {

        await GraphService.InitZoomPan(dotnetreference, GraphModel.Name);
        await GraphService.Crop();
        await GraphService.Resize();
    }

    public async void DisablePan()
    {
        await GraphService.DisablePan();
    }
    public async void EnablePan()
    {
        await GraphService.EnablePan();
    }

    #region EventHandling
    public bool NodeDragStarted = false;

    public event EventHandler<MouseEventArgs> SvgClick;
    public event EventHandler<MouseEventArgs> SvgMouseDown;
    public event EventHandler<MouseEventArgs> SvgMouseUp;
    public event EventHandler<MouseEventArgs> SvgMouseMove;
    public event EventHandler<WheelEventArgs> SvgMouseWheel;
    public event EventHandler<KeyboardEventArgs> SvgKeyDown;

    public event EventHandler<TouchEventArgs> SvgTouchMove;

    public event EventHandler<GraphMouseEventArgs<Node>> NodeClick;
    public event EventHandler<GraphMouseEventArgs<Node>> NodeMouseDown;
    public event EventHandler<GraphMouseEventArgs<Node>> NodeMouseUp;
    public event EventHandler<GraphMouseEventArgs<Node>> NodeMouseMove;

    public event EventHandler<GraphTouchEventArgs<Node>> NodeTouchStart;
    public event EventHandler<GraphTouchEventArgs<Node>> NodeTouchEnd;
    public event EventHandler<GraphTouchEventArgs<Node>> NodeTouchEnter;

    public event EventHandler<WheelEventArgs> NodeMouseWheel;

    protected virtual void OnSvgClick(MouseEventArgs e)
    {

        EventHandler<MouseEventArgs> handler = SvgClick;
        if (handler != null && NodeClick == null)
        {
            handler(this, e);
        }
    }
    protected virtual void OnSvgMouseDown(MouseEventArgs e)
    {
        EventHandler<MouseEventArgs> handler = SvgMouseDown;
        if (handler != null)
        {
            handler(this, e);
        }
    }
    protected virtual void OnSvgMouseUp(MouseEventArgs e)
    {
        EventHandler<MouseEventArgs> handler = SvgMouseUp;
        if (handler != null)
        {
            handler(this, e);
        }
    }
    protected virtual void OnSvgMouseMove(MouseEventArgs e)
    {
        EventHandler<MouseEventArgs> handler = SvgMouseMove;
        if (handler != null)
        {
            handler(this, e);
        }
    }
    protected virtual void OnSvgMouseWheel(WheelEventArgs e)
    {
        EventHandler<WheelEventArgs> handler = SvgMouseWheel;
        if (handler != null)
        {
            handler(this, e);
        }
    }
    protected virtual void OnSvgKeyDown(KeyboardEventArgs e)
    {
        EventHandler<KeyboardEventArgs> handler = SvgKeyDown;
        if (handler != null)
        {
            handler(this, e);
        }
    }

    protected virtual void OnSvgTouchMove(TouchEventArgs e)
    {

        EventHandler<TouchEventArgs> handler = SvgTouchMove;
        if (handler != null)
        {
            handler(this, e);
        }
    }


    protected virtual void OnNodeClick(MouseEventArgs e, Node node)
    {
        EventHandler<GraphMouseEventArgs<Node>> handler = NodeClick;
        if (handler != null)
        {
            handler(this, new GraphMouseEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnTouchStart(TouchEventArgs e, Node node)
    {
        EventHandler<GraphTouchEventArgs<Node>> handler = NodeTouchStart;
        if (handler != null)
        {
            handler(this, new GraphTouchEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnTouchEnd(TouchEventArgs e, Node node)
    {
        EventHandler<GraphTouchEventArgs<Node>> handler = NodeTouchEnd;
        if (handler != null)
        {
            handler(this, new GraphTouchEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnTouchEnter(TouchEventArgs e, Node node)
    {
        EventHandler<GraphTouchEventArgs<Node>> handler = NodeTouchEnter;
        if (handler != null)
        {
            handler(this, new GraphTouchEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnNodeMouseDown(MouseEventArgs e, Node node)
    {
        EventHandler<GraphMouseEventArgs<Node>> handler = NodeMouseDown;
        if (handler != null)
        {
            handler(this, new GraphMouseEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnNodeMouseUp(MouseEventArgs e, Node node)
    {
        EventHandler<GraphMouseEventArgs<Node>> handler = NodeMouseUp;
        if (handler != null)
        {
            handler(this, new GraphMouseEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnNodeMouseMove(MouseEventArgs e, Node node)
    {
        EventHandler<GraphMouseEventArgs<Node>> handler = NodeMouseMove;
        if (handler != null)
        {
            handler(this, new GraphMouseEventArgs<Node>(node, e));
        }
    }
    protected virtual void OnNodeMouseWheel(WheelEventArgs e)
    {
        EventHandler<WheelEventArgs> handler = NodeMouseWheel;
        if (handler != null)
        {
            handler(this, e);
        }
    }
    #endregion

    #region Defaut Callbacks
    public void RegisterDefaultSvgKlick()
    {
        this.SvgClick += DefaultCallbacks.DeactivateNode;
    }
    public void RegisterDefaultNodeMouseDown()
    {
        this.NodeMouseDown += DefaultCallbacks.ActivateNode;
    }
    public void RegisterDefaultNodeTouchStart()
    {

    }

    public void RegisterDefaultNodeCallbacks() {
        RegisterDefaultSvgKlick();
        RegisterDefaultNodeMouseDown();
        RegisterDefaultNodeTouchStart();
        this.NodeTouchStart += async (sender, args) =>
        {
            Node node = args.Target;
            if (GraphModel.ActiveNode != null)
            {
                if (GraphModel.ActiveNode.Id == node.Id)
                {
                    node.IsActive = false;
                }
                else
                {
                    GraphModel.ActiveNode.IsActive = false;
                    node.IsActive = true;
                }
            }
            else
            {
                node.IsActive = true;
            }
            this.NodeDragStarted = true;
            await GraphService.DisablePan();
        };
        this.NodeMouseUp += async (sender, args) =>
        {
            this.NodeDragStarted = false;
            await GraphService.EnablePan();
        };
        this.NodeTouchEnd += async (sender, args) =>
        {
            this.NodeDragStarted = false;
            await GraphService.EnablePan();
        };
        this.SvgMouseMove += async (sender, args) =>
        {
            if (GraphModel.ActiveNode != null && this.NodeDragStarted)
            {
                try
                {
                    Point2 coords = await GraphService.GetTranslatedMousePos(GraphModel.Name, args.ClientX, args.ClientY);
                    GraphModel.ActiveNode.Pos.X = Convert.ToSingle(coords.X);
                    GraphModel.ActiveNode.Pos.Y = Convert.ToSingle(coords.Y);
                }
                catch { }
            }
        };
        this.SvgTouchMove += async (sender, args) =>
        {
            if (GraphModel.ActiveNode != null && this.NodeDragStarted)
            {
                try
                {
                    Point2 coords = await GraphService.GetTranslatedMousePos(GraphModel.Name, args.Touches.First().ClientX, args.Touches.First().ClientY);
                    GraphModel.ActiveNode.Pos.X = Convert.ToSingle(coords.X);
                    GraphModel.ActiveNode.Pos.Y = Convert.ToSingle(coords.Y);
                }
                catch { }
            }
        };
        this.SvgMouseUp += (sender, args) =>
        {
            StateHasChanged();
        };
        this.NodeClick += (sender, args) =>
        {
            Node node = args.Target;
            if (GraphModel.ActiveNode != null)
            {
                if (GraphModel.ActiveNode.Id == node.Id)
                {
                    node.IsActive = false;
                }
                else
                {
                    GraphModel.ActiveNode.IsActive = false;
                    node.IsActive = true;
                }
            }
            else
            {
                node.IsActive = true;
            }
        };
    }
    #endregion
}

