@page "/algorithm/dijkstra"
@page "/algorithm/dijkstra/{filename}"
@using System.IO
@using Blazored.Toast;

@inherits AlgorithmPage

<Modal @ref="ModalNegativeEdgeWeigths" Title="Negatives Kantengewicht gefunden">
    <div class="card">
        <div class="card-body">
            <p class="card-text">Es wurden negative Kanten im Graph gefunden. Der Dijkstra - Algorithmus kann nicht mit negativen Kanten umgehen. Sollen diese Kanten korrigiert werden? Dadurch wird |@LowestWeight| auf alle Kanten- Gewichte addiert!</p>
            <button class="btn btn-outline-success" @onclick="@(() => { CorrectEdgeWeights(); ModalNegativeEdgeWeigths.Show(); })">Kanten korrigieren</button>
        </div>
    </div>
</Modal>
<div class="flex-wrapper">
    <div class="flex-wrapper-title">

        @if (GraphService.CurrentGraphModel != null)
        {
            <h3>Dijkstra Algorithmus</h3>
            <form class="form position-absolute">
                <button class="btn btn-outline-primary form-control" type="button" @onclick="@(() => RunAlgorithm())">Dikstra Einzelschritt</button>
                <button class="btn btn-outline-primary form-control" type="button" @onclick="@(() => RunAlgorithm(true))">Dikstra ausführen</button>
                <button class="btn btn-outline-primary form-control" type="button" @onclick="@DijkstraCheapestRoute">Günstigste Route ermitteln</button>
            </form>
        }
        else
        {
            <h3>Dijkstra Algorithmus</h3>
        }
    </div>
    <hr />
    <div class="left-container">
        @GraphService.GetRenderFragment().Result
    </div>

    @if (Algorithm?.Results != null)
    {
        <div class="row right-container" style="@(expanded == 2?"flex-basis:100%":expanded == 0?"max-width:50px":"")">
            <div class="expander" @onclick="@collapsetable"><span class="oi @(expanded < 2?"oi-chevron-left":"oi-chevron-right")" aria-hidden="true"></span></div>
            <div class="expanding col card pb-5">
                <div class="card-body">
                    <AlgorithmResultTable Algorithm="@Algorithm" />
                    <div>
                        @if (ShortestRouteToEndnode != null)
                        {
                            if (ShortestRouteToEndnode.Count == 1)
                            {
                                <h5>Die günstigste/kürzeste Route von @(Algorithm.StartNode.Name ?? Algorithm.StartNode.Id.ToString()) nach @(Algorithm.EndNode.Name ?? Algorithm.EndNode.Id.ToString()) konnte nicht ermittelt werden </h5>
                            }
                            else
                            {
                                <h5>Die günstigste/kürzeste Route von @(Algorithm.StartNode.Name ?? Algorithm.StartNode.Id.ToString()) nach @(Algorithm.EndNode.Name ?? Algorithm.EndNode.Id.ToString()) </h5>
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Reihenfolge</th>
                                            @for (int i = 0; i < ShortestRouteToEndnode.Count; i++)
                                            {
                                                <th>@(i + 1)</th>
                                            }
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <th>ID</th>
                                            @foreach (var node in ShortestRouteToEndnode)
                                            {
                                                <td>@node.Item1.Id</td>
                                            }
                                        </tr>
                                        <tr>
                                            <th>Name</th>
                                            @foreach (var node in ShortestRouteToEndnode)
                                            {
                                                <td>@node.Item1.Name</td>
                                            }
                                        </tr>
                                        <tr>
                                            <th>Kosten</th>
                                            @foreach (var node in ShortestRouteToEndnode)
                                            {
                                                <td>@node.Item2</td>
                                            }
                                        </tr>
                                        <tr>
                                            <th>Gesamtkosten:</th>
                                            <td>@PathCost.ToString(CultureInfo.CurrentCulture)</td>
                                        </tr>
                                    </tbody>
                                </table>
                            }
                        }
                    </div>
                </div>
            </div>


        </div>
    }

</div>
@code {

    int expanded = 1;
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            GraphService.CurrentGraph.NodeClick += (sender, args) =>
            {
                resetPreview();
                resetUnreachables();
                if (args.Target.IsActive && !GraphService.CurrentGraphModel.Nodes.Any(x => x.Classes.Contains(AlgorithmPage.StartNodeClass) && !args.Target.Classes.Contains(AlgorithmPage.StartNodeClass)))
                {

                    DijkstraAlgorithm runner = new DijkstraAlgorithm(GraphService.CurrentGraphModel, args.Target.Id);
                    runner.Iterate(auto: true);
                    var lastresult = runner.Results.Last();
                    var nodes = lastresult.Distances.Where(x => x.Value != double.PositiveInfinity).Select(x => x.Key).ToList();
                    var previewEdges = nodes.SelectMany(x => x.Edges.Where(y => x == y.StartNode)).ToList();
                    nodes.ForEach(x => { if (!x.Classes.Contains(AlgorithmPage.NodeReachableClass)) x.Classes.Add(AlgorithmPage.NodeReachableClass); });
                    previewEdges.ForEach(x => { if (!x.Classes.Contains(AlgorithmPage.NodeReachableClass)) x.Classes.Add(AlgorithmPage.NodeReachableClass); });
                }
            };
        }
    }

    protected override async void RunAlgorithm(bool autostep = false)
    {
        resetPreview();
        CheckNegativeAndShowModal();
        if (Algorithm == null)
        {

            var startNodeId = GraphService.CurrentGraphModel.Nodes.FirstOrDefault(x => x.Classes.Contains(StartNodeClass))?.Id ?? "-1";
            if (startNodeId != "-1")
            {

                Algorithm = new DijkstraAlgorithm(GraphService.CurrentGraphModel, startNodeId);

            }
            else
            {
                toastService.ShowError("Es muss ein Startknoten per Rechtsklick gewählt werden.");
                return;
            }
            clearRouteClasses();
            ShortestRouteToEndnode = null;
            setUnreachables();
        }
        if (Algorithm.RemainingSteps > 0)
        {
            Algorithm.Iterate(autostep);
            setPreview();
            await GraphService.Rerender();
        }
        else
        {
            toastService.ShowInfo("Es wurden alle Knoten verarbeitet. Der Algorithmus beginnt erneut");
            removeClassFromNodesAndEdges(AlgorithmPage.IterationCurrentNodeClass);
            removeClassFromNodesAndEdges(AlgorithmPage.IterationClass);
            resetUnreachables();
            Algorithm = null;
            RunAlgorithm(autostep);
        }
    }

    private async void DijkstraCheapestRoute()
    {
        CheckNegativeAndShowModal();
        PathCost = 0;
        var startnodeId = GraphService.CurrentGraphModel.Nodes.FirstOrDefault(x => x.Classes.Contains(AlgorithmPage.StartNodeClass))?.Id ?? "-1";
        var endnodeId = GraphService.CurrentGraphModel.Nodes.FirstOrDefault(x => x.Classes.Contains(AlgorithmPage.EndNodeClass))?.Id ?? "-1";
        if (startnodeId == "-1" || endnodeId == "-1")
        {
            toastService.ShowError("Es muss ein Start- und Endknoten per Rechtsklick gewählt werden.");
            return;
        }
        if (ShortestRouteToEndnode != null)
        {
            clearRouteClasses();
        }

        Algorithm = new DijkstraAlgorithm(GraphService.CurrentGraphModel, startnodeId);

        ShortestRouteToEndnode = Algorithm.GetShortestRoute(startnodeId, endnodeId);
        visualizeRoute();
        await GraphService.Rerender();
    }
    private void collapsetable()
    {
        expanded = expanded < 2 ? expanded + 1 : 0;
        StateHasChanged();
    }
}